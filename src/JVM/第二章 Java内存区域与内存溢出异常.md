#Java与C++的区别
##2.1 概述
内存管理领域
- c,c++开发人员拥有最高权利,可以操作每一个对象,又需要维护每个对象的开始与销毁
- java开发人员不需要为每一个对象写配对的delete/free代码,不容易出现内存泄露与内存溢出问题,不过,出现内存方面的问题,排查又是一项异常艰难的工作
##2.2运行时数据区域
- 方法区Method Area
- 虚拟机栈VM Stack
- 本地方法栈Native Method Stack
- 堆 Heap
- 程序计数器 program Counter Register
###2.2.1 程序计数器
java虚拟机通过线程轮换来分配处理器执行时间,为了线程切换后能恢复到正确的执行位置,每条线程都需要一个独立的程序计数器,为*线程私有*内存
###2.2.2 Java虚拟机栈
与程序计数器一样,Java虚拟机栈也是线程私有的,它的生命周期与线程相同.
###2.2.3 本地方法栈
本地方法栈为虚拟机使用到的Native方法服务
###2.2.4 Java堆
Java堆(Heap)是Java虚拟机所管理的 内存中最大的一块,Java对是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例.
Java堆是垃圾收集器管理的主要区域
现在的收集器基本采用分代收集算法
####Java堆
- 新生代
- 老年代
更细致
- Eden空间
- From Survivor空间
- To Survivor空间

Java堆可以处于物理上不连续的空间中,只要逻辑上连续即可,既可以实现成固定大小的,也可以是可扩展的,通过 *-Xmx* 和 *-Xms*控制,如果堆中没有足够的内存完成实例分配,则报 *OutOfMemory* 异常

###2.2.5
方法区与Java堆一样,是各个线程共享的内存区域,用于存放已被虚拟机加载的类信息,敞亮,静态变量,即时编译器编译后的代码等数据

HotSpot上,方法区习惯性称为 *永久代(Permanent Generation)* 

永久代有 *-XX:MaxPermSize* 上限
###2.2.6 运行时常量池
运行时常量池(Runtime Constant Pool)是方法区的一部分.用于存放编译期生成的各种字面量和符号引用.

当常量池无法申请到内存报OutOfMemory异常
###直接内存
JDK1.4中新加入NIO(New Input/Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用记性操作.
作用:提高性能
直接内存不收Java堆大小的限制,但是受本机总内存限制.除了设置 -Xmx等参数信息,也要注意直接内存


##2.3 HotSpot虚拟机对象探秘
###2.3.1 对象的创建
####划分内存
虚拟机遇到一条new指令时,首先检查常量池中有没有这个类的符号引用,检查是否已被加载,解析,初始化过.如果没有,那必须先执行相应的类加载过程
通过检查之后,接下来虚拟机将为新生对象分配内存.

*指针碰撞(Bump the Pointer):* 如果内存是规整的,那么就将指针从已使用内存向空闲内存移动对象大小的距离

*空闲列表(Free List):* 如果内存是不规整的,已使用的内存和空闲的内存项目交错,虚拟机就必须尾货一个列表,记录那些内存块是可用的,分配内存块,更新列表

选择那种分配方式由垃圾收集器是否带有压缩整理功能决定
 
指针碰撞,代用Compact过程的收集器
- Serial
- ParNew

空闲列表,基于Mark-Sweep算法的收集器
- CMS

####保证线程安全
1. 对分配内存空间的动作进行同步处理---实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性
1. 把内存分配动作按照线程划分在不同的空间之中进行,即每个线程在Java堆中预先分配一小块内存,称为本地线程分配缓冲(Thread Local Allocation Buffer).虚拟机是否使用TLAB,可以通过-XX:+/-UseTLAB 参数设定
###2.3.2 对象的内存布局
在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域
1. 对象头(Header)
    1. 运行时数据,如哈希码,GC分代你年龄,锁状态标识,线程持有的锁,偏向线程Id,偏向时间戳
    1. 类型指针,虚拟机通过这个指针确定这个对象是哪个类的示例
1. 实例数据(Instance Data)
    1. 各种类型的字段内容
1. 对齐填充(Padding)
    1. 不是必然存在,由于HotSpot Vm的自动内存管理系统要求对象起始地址必须是8字节的整数倍,当对象实例数据部分没有对齐时,就需要通过对齐填充来补全
###2.3.3 对象的访问定位
主流方式

HotSpot采用直接指针方式

1. 使用句柄
    - 原理:划分出一块内存作为句柄池.reference中存储的就是对象的句柄地址,句柄中包含了对象实例数据与类型数据各自的具体地址信息
    - 优点:reference中存储的是稳定的句柄地址,在对象被移动时,只会改变句柄中的实例数据指针,而reference本身不需要修改
2. 直接指针
    - 原理:Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息,而reference中存储的直接就是对象地址
    - 优点:速度更快,少了一次通过句柄定位指针的开销
    
##2.4 实战:OutOfMemoryError异常








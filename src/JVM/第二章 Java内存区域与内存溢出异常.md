#Java与C++的区别
##2.1 概述
内存管理领域
- c,c++开发人员拥有最高权利,可以操作每一个对象,又需要维护每个对象的开始与销毁
- java开发人员不需要为每一个对象写配对的delete/free代码,不容易出现内存泄露与内存溢出问题,不过,出现内存方面的问题,排查又是一项异常艰难的工作
##2.2运行时数据区域
- 方法区Method Area
- 虚拟机栈VM Stack
- 本地方法栈Native Method Stack
- 堆 Heap
- 程序计数器 program Counter Register
###2.2.1 程序计数器
java虚拟机通过线程轮换来分配处理器执行时间,为了线程切换后能恢复到正确的执行位置,每条线程都需要一个独立的程序计数器,为*线程私有*内存
###2.2.2 Java虚拟机栈
与程序计数器一样,Java虚拟机栈也是线程私有的,它的生命周期与线程相同.
###2.2.3 本地方法栈
本地方法栈为虚拟机使用到的Native方法服务
###2.2.4 Java堆
Java堆(Heap)是Java虚拟机所管理的 内存中最大的一块,Java对是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例.
Java堆是垃圾收集器管理的主要区域
现在的收集器基本采用分代收集算法
####Java堆
- 新生代
- 老年代
更细致
- Eden空间
- From Survivor空间
- To Survivor空间

Java堆可以处于物理上不连续的空间中,只要逻辑上连续即可,既可以实现成固定大小的,也可以是可扩展的,通过 *-Xmx* 和 *-Xms*控制,如果堆中没有足够的内存完成实例分配,则报 *OutOfMemory* 异常

###2.2.5
方法区与Java堆一样,是各个线程共享的内存区域,用于存放已被虚拟机加载的类信息,敞亮,静态变量,即时编译器编译后的代码等数据

HotSpot上,方法区习惯性称为 *永久代(Permanent Generation)* 

永久代有 *-XX:MaxPermSize* 上限
###2.2.6 运行时常量池
运行时常量池(Runtime Constant Pool)是方法区的一部分.用于存放编译期生成的各种字面量和符号引用.

当常量池无法申请到内存报OutOfMemory异常
###直接内存
JDK1.4中新加入NIO(New Input/Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用记性操作.
作用:提高性能
直接内存不收Java堆大小的限制,但是受本机总内存限制.除了设置 -Xmx等参数信息,也要注意直接内存


##2.3 HotSpot虚拟机对象探秘
###2.3.1 对象的创建



#第三章 垃圾收集器与内存分配策略

##3.1概述
垃圾收集(Garbage Collection,GC),大部分人都把这项技术当做Java语言的伴生产物,事实上,1960年诞生于MIT的Lisp蚕食第一门真正使用内存动态分配和垃圾收集技术的语言

GC的3件事情
- 那些内存需要回收
- 什么时候回收
- 如何回收

目前GC的技术已经相当成熟,为什么我们要了解
- 当需要排查各种内存溢出,内存泄露问题时
- 当垃圾收集成为系统达到更高并发量瓶颈时

##3.2对象已死吗
Java堆中存在对象实例,垃圾收集器在对堆进行回收前,第一件事就是要确定哪些对象还"活着",哪些已经"死去"

##3.2.1 引用计数算法
给对象中添加一个引用计数器:每当有一个地方引用它时,计数器加1;当引用失效时,计数器减1;任何时刻计数器为0的对象就是不可能再被使用的

引用计数算法(Reference Counting)的实现简单,判定效率也高,例如FlashPlayer,Python都使用引用计数算法了内存管理,但是Java虚拟机中没有选用引用计数算法来管理内存,其实最重要的原因是它很难解决对象之间相互循环引用的问题

testGC()方法,虽然两个对象已经不可能被访问,但是因为互相引用着,导致他们计数器都不为0,于是引用计数算法无法通知GC收集器来回收它们

GC日志中包含了6747K->416K(51200K),意味着虚拟机并没有因为这两个对象互相引用就不回收它们,这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否是存活的

##3.2.2 可达性分析算法
在主流的商用程序语言(Java,C#,甚至古老的Lisp)的主流实现中,都是通过可达性分析(Reachability Analysis)来判定对象是否存活的.这个算法的基本思路就是通过一系列的称为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),